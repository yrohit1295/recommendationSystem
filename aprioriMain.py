"""
The script shows the implementation of Apriori algorithm which return frequent itemsets to show
relationship among items of particular transaction. The association rule is created form the
frequent itemsets generated by Apriori algorithm
"""

import sys
from instaApriori import InstaApriori
from itertools import combinations
import datetime

transaction_count = None
k_minus_one_itemsets = {}


def runjob(job, iteration):
    """
    The function is used to run the job on mapreduce framework and it return the frequent items which
    are greater than minimum support threshold
    :param job: Object returns from map reduce of MRJob
    :param iteration: int
    :return: dict
    """
    with job.make_runner() as runner:
        print("Running iteration {}\n".format(job.options.iteration))
        runner.run()
        if iteration == 1:
            # print(iteration)
            global transaction_count
            counters = runner.counters()
            # transaction_count = counters[0]['association_rules']['transaction_count']
            transaction_count = counters[1]['association_rules']['transaction_count']
        for key, value in job.parse_output(runner.cat_output()):
            if iteration >= job.options.k - 1:
                if value / transaction_count >= float(job.options.s):
                    yield set(key), value / transaction_count
        fh.close()


if __name__ == '__main__':
    start_time = datetime.datetime.now().replace(microsecond=0)
    args = sys.argv[1:]
    job = InstaApriori(args + ['-iteration', '1'])
    k = job.options.k
    for i in range(1, k + 1):
        job = InstaApriori(args=args + ['-iteration', str(i)])
        results = runjob(job, iteration=i)
        if i == job.options.k - 1:
            for result in results:
                k_minus_one_itemsets[frozenset(result[0])] = result[1]
        elif i == job.options.k:
            for result in results:
                lhs_items = combinations(result[0], job.options.k - 1)
                for lhs_item in lhs_items:
                    confidence = list(result)[1] / k_minus_one_itemsets[frozenset(lhs_item)]
                    support = result[1]
                    if confidence > job.options.c:
                        rhs_item = next(iter(set(result[0]).difference(lhs_item)), '')
                        output_string = "{} ---> {}. support = {}, confidence = {}"
                        print(output_string.format(
                            ",".join(lhs_item),
                            rhs_item,
                            support,
                            confidence))

        else:
            fh = open(job.options.f, "w")
            for result in results:
                key = result[0]
                value = result[1]
                if value / transaction_count >= float(job.options.s):
                    fh.write('{}\n'.format(key))
                    if iteration == job.options.k:
                        if job.options.k == 1:
                            print(key)
                        else:
                            print(set(key))
            fh.close()

    print("Total Execution Time = {}".format(datetime.datetime.now().replace(microsecond=0) - start_time))
